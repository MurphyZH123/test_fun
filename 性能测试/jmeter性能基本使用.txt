1、jemter基础功能组件介绍线程组和Sampler
	简介：讲解jmeter里面GUI菜单栏主要组件

	（1）、添加->threads->线程组(控制总体并发)
	线程数：虚拟用户数。一个虚拟用户占用一个进程或线程
	准备时长（Ramp-Up-Period（in-second）：全部线程启动的时长，比如100个线程，20秒，则表示20秒内100个线程都要启动完成，每秒启动5个线程

	循环次数：每个线程发送的次数，假如值为5，100个线程，则会发送500次请求，可以勾选为永远循环

	（2）、线程组->添加->Sampler(采样器)->Http(一个线程组下面可以增加几个Sampler)
		名称：采样器名称
		注释：对这个采样器的描述

		web服务器：
			默认协议是http
			默认端口是80
			服务器名称或IP：请求的目标服务器或IP地址
		路径：服务器URL

		Use multipart/from-data for HTTP POST：当发送POST请求时，使用Use multipart/form-data方法发送，默认不选中

	（3）、查看测试结果
	线程组->添加->监听器->查看结果树


2、jmeter断言的使用
	简介：介绍什么是断言及基本使用


	（1）增加断言：线程组->添加->断言->响应断言
	
	apply to（应用范围）：
		Main sample only：仅当前父取样器进行断言，一般一个请求，如果发一个请求会触发多个，则就有sub sample（比较少用）
	要测试的

	要测试的响应字段：
		响应文本：即响应的数据，比如json等文本
		响应代码：http的响应状态码，比如200，302，404这些
		响应信息：http的响应代码对应的响应信息，例如：OK，Found
		Response Header：响应头

	模式匹配规则：
		包括：包含在里面就成功
		匹配：响应内容完全匹配，不区分大小写
		equals：完全匹配，区分大小写

	（2）断言结果监听器：线程组->添加->监听器->断言结果
		里面的内容是sampler采样器的名称
		断言失败，查看结果树任务结果颜色标红（通过结果树里面双击不通过的记录，可以看到错误信息）

	（3）每个sample下面可以加单独的结果树，然后同时加多个断言，最外层可以加个结果树进行汇总

3、压测结果聚合报告分析
	简介：讲解压测结果的聚合报告
	新增聚合报告：线程组->添加->监听器->聚合报告（Aggeregate Report）

4、jmeter用户自定义变量实战
	简介：什么是用户自定义变量，怎样使用

	为什么使用：很多变量在全局中都有使用，或者测试数据更改，可以在一处定义，四处使用
	比如服务器地址

	（1）线程组->add->Config Element（配置原件）->User Definde Vairable（用户自定义变量）
	（2）引用方式${xxx},在接口中变量使用
	（3）原始查看结果树和非原生查看（基础按钮）

5、jmeter实战之CSV可变参数压测实战
	简介：
		实战操作jmeter读取CSV和Txt文本文件里面的参数进行压测
		（1）线程组->add ->Config Element（配置原件） ->CSV data set config（CSV数据文件设置）

6、jmeter压测实战之jdbc request压测mysql讲解
	简介：讲解jdbc压测mysql相关准备工作，jar包添加，配置讲解
	(1)thread group -> add -> sampler -> jdbc request 
	(2)jar包添加 mysql-connector-java-5.1.30.jar
	(3)参数讲解：	(sql结尾不要加";")
		1、variable name of pool declared in JDBC connection configuration(和配置文件同名)
		2、Query Type 查询类型
		3、parameter values 参数值
		4、parameter type 参数类型
		5、variable names sql执行结果变量名
		6、result variable names 所有结果当成一个对象存储
		7、query timeouts 查询超时时间
		8、handle results 处理结果集
	（4）jdbc connection configuration 配置
		1、jdbc request -> add ->config element -> jdbc connection configuration
			核心配置
				Max Number of connections：最大连接数
				Max wait：最大等待时间
				Auto Commit：是否自动提交事务

				DataBase URL ：数据库连接地址 jdbc:mysql://127.0.0.1:3306/bolg
				JDBC Driver Class:数据库驱动，选择对应的mysql
				username:数据库用户名
				password:数据库密码

7、jmeter压测实战之jdbc request压测mysql，select语句
	简介：使用jmeter压测mysql，select，insert语句
	（1）Debug Sampler使用（结果树中查看）
		Thread Group -> add -> sampler -> debug sampler
	（2）参数讲解：（sql结尾不要加";")
		1、variable name of pool declared in jdbc connection configuration（和配置文件同名）
		2、Query Type 查询类型
		3、parameter values 参数值
		4、parameter type 参数类型
		5、variable names  sql执行结果变量名
		6、result variable names 所有结果当作一个对象存储
		7、query timeouts 查询超时时间
		8、handle results 处理结果集

8、分布式压测介绍
	普通压测：单台机可以对目标机器产生的压力较小，受限因素包括CPU、网络、IO等
	分布式压测：利用多台机器向目标机器产生压力，模拟几万用户并发访问

9、jmeter分布式压测原理
	简介：讲解jmeter分布式压测原理
		(1)总空机器的节点master，其他产生压力的机器叫“肉鸡”server
		(2)master会把压测脚本发送到 server上面
		(3)执行的时候，server上只需要把jmeter-server打开就可以了，不用启动jmeter
		(4)结束后，server会把压测数据回传给master，然后master汇总输出报告
		(5)配置详情
10、jmeter非gui界面 参数讲解
	讲解：非gui界面，压测参数讲解
		-h 帮助
		-n 非gui模式
		-t 指定要运行的jmeter测试脚本文件
		-l 记录结果的文件 每次运行之前，(要确保之前没有运行过，即xxx.jtl不存在，不然报错)
		-r jmeter.properties文件中指定的所有远程服务器
		-e 在脚本运行结束后生成html报告
		-o 用于存放html报告的目录（目录要为空，不然报错）

	jmeter -n -t Linux_users_api.jmx -l result.jtl -e -o /usr/local/softwate/jmeter/temp/ResultReport

	jmeter -n -t /Users/jack/Desktop/linux_users_api.jmx -l result.jtl -e -o /Users/jack/Desktop/jmeter/temp


11、jmeter图形化HTML压测报告dashboard讲解
	简介：
		讲解压测报告 html里面Dashboard的核心指标
		1、dashboard讲解
			1）Test and Report informations
				source file：jtl文件名
				start time：压测开始时间
				end time：压测结束时间
				filter for display：过滤器
				lable：sampler采样器名称
			2）APDEX(Application performance Index)
				apdex：应用程序性能指标，范围在0～1之间，1表示达到所有用户均满意
				T(Toleration threshold):可接受阀值
				F(Frustration threshold):失败阀值
			3）Requests Summary
				OK:成功率
				KO:失败率
			4）Statistics 统计数据
				lable:sampler采样器名称
				samples:请求总数，并发数*循环次数
				KO:失败次数
				Error%:失败率

				Average:平均响应时间
				Min:最小响应时间
				Max:最大响应时间
				90th pct:90%的用户响应时间不会超过这个值（关注这个就可以了）
				95th pct:95%的用户响应时间不会超过这个值
				99th pct:99%的用户响应时间不会超过这个值(存在极端值)
				throughput:Request per Second吞吐量 qps
				



流量指标-互联网的数据术语（VV UV PV IP）

1、来访次数/访问次数(VV)：VV = VisitView(访问次数)：记录所有访客1天内访问了多少次你的网站，相同的访客有可能多次访问您的网站。从访客来到您网站到最终关闭网站的所有页面离开，计为1次访问。若访客连续30分钟没有新开和刷新页面，或者访客关闭了浏览器，则被计算为本次访问结束。那么上图A就是从搜索词“宫外孕有什么症状”进入网站的访问次数329.

2、独立访客(UV)：1天内相同访客多次访问网站，只计算为1个独立访客。上图数据就是1天内从搜索词“宫外孕有什么症状”进入网站的独立访客294.

3、浏览次数(PV)：即通常说的PV(PageView)值，用户每打开1个网站页面，记录1个PV。用户多次打开同一页面PV累计多次。用以衡量网站用户访问的网页数量。上图数据意思从搜索词“宫外孕有什么症状”进入网站的访客浏览次数是360.

4、独立IP数：1天(00:00-24:00)之内，访问网站的不重复IP数。一天内相同IP地址多次访问网站只被计算1次。同一IP无论访问了几个页面，独立IP数均为1访问次数，

一、性能测试影响因素
1、响应时间：对请求作出相应所需要的时间
  	网络传输时间：N1+N2+N3+N4
  	应用服务器处理时间：A1+A3
  	数据库服务器处理时间：A2
  	响应时间：N1+N2+N3+N4+A1+A3+A2
2、并发用户数的计算公式
	系统用户数：系统额定的用户数量
	同时在线用户数：在一定时间范围内，最大的同时在线用户数量
	平均并发用户数的计算：C = nl/T
		其中，C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session）的平均时间，T是考察时间长度（一天内多长时间用户使用系统）
	并发用户数峰值计算：C^约等于C+3*√C
		其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论
3、吞吐量计算公式
	当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU*R/T
	其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T代表性能测试所用的时间
4、性能计数器
	资源利用率：指系统各种资源的使用情况，如CPU占用率为68%，内存占用率55%，一般使用“资源实际使用/总的资源可用量，形成资源利用率
	性能计数器是描述服务器或操作系统性能的一些数据指标
5、思考时间的计算公式
	Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做性能测试的时候，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。
	在吞吐量这个公式中,(F=VU*R/T)说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R=T/TS

二、高并发性能指标QPS、TPS、RT、并发数、吞吐量、吞吐量详解
1、QPS，每秒查询
QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。（每秒钟处理完的请求次数，注意这里是处理完）

2、TPS，每秒事务
TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。

3、RT，响应时间
响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。

4、并发数
并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。

5、吞吐量
系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。

QPS（TPS）：（Query Per Second）每秒钟request/事务 数量
并发数： 系统同时处理的request/事务数
响应时间： 一般取平均响应时间
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间
并发数 = QPS*平均响应时间

6、实际举例
我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20%时间就叫做峰值时间。
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器
（1）、每天300w PV 的在单台机器上，这台机器需要多少QPS？ 
	( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)

（2）、如果一台机器的QPS是58，需要几台机器来支持？ 
	139 / 58 = 3

7、最佳线程数、QPS、RT
（1）、单线程QPS公式：QPS=1000ms/RT
	对同一个系统而言，支持的线程数越多，QPS越高。假设一个RT是80ms,则可以很容易的计算出QPS,QPS = 1000/80 = 12.5
	多线程场景，如果把服务端的线程数提升到2，那么整个系统的QPS则为 2*（1000/80） = 25, 可见QPS随着线程的增加而线性增长，那QPS上不去就加线程呗，听起来很有道理，公司也说的通，但是往往现实并非如此。

（2）、QPS和RT的真实关系
	我们想象的QPS、RT关系是随着RT的逐渐增大，QPS逐渐降低的凹曲线
	实际的QPS、RT关系是随着RT的逐渐增大，QPS逐渐降低的凸曲线

（3）、最佳线程数量
	刚好消耗完服务器的瓶颈资源的临界线程数，公式如下
	最佳线程数量=（（线程等待时间+线程cpu时间）/线程cpu时间）* cpu数量
	特性：
	在达到最佳线程数的时候，线程数量继续递增，则QPS不变，而响应时间变长，持续递增线程数量，则QPS开始下降。
	每个系统都有其最佳线程数量，但是不同状态下，最佳线程数量是会变化的。
	瓶颈资源可以是CPU,可以是内存，可以是锁资源，IO资源：超过最佳线程数-导致资源的竞争，超过最佳线程数-响应时间递增。


三、Jmeter仅一次控制器Once only Controller使用案例
1、Once-only-Controller仅一次控制器，它下面的原件只会运行一次。即使Once-only-Controller是在循环控制器下，也只会运行一次
2、场景
	多个并发用户，每个用户需要先登录，而且只需要登录一次，每个并发登录成功后，会产生一个accessToken，也就是代表了登录服务端登录鉴权通过后，返回给请求调用的一个标志，在后面具体的Http接口请求中，每个并发用户都需要在请求中传入这个accessToken，不然的话，服务端的鉴权就是失败。
3、压测脚本设置
	（1）在线程组添加Once only Controller，在Once only Controller下添加Http请求（登录）
		登录请求在Once only Controller下至可循环一次（做数据驱动时），如线程组数量为5，循环次数为10，仅一次控制器（Once only Controller）下有个Http请求采样器，在查看结果树下只有5次返回结果。
	（2）然后将登录的cookies传给下一个接口，此时，在查看结果树下，查看登录接口的响应数据中的Response headers，在头信息中会有set-cookies，得到set-cookies之后，在登录请求后添加正则表达提取器将set-cookies的值提取出来，使用正则表达式【set-cookies:(.*)】，然后将cookies值提取出来，提取成功之后，添加BeanShell PostProcessor，将cookies值传入下一个接口。
4、补充
	（1）在添加正则表达提取器之后，可以添加“调试取样器（Debug Sampler）“验证提取的数据是否成功
	（2）接口走通之后，便可以做数据驱动

四、定时器详解
1、定时器的作用域
	（1）定时器是在每个sampler（采样器）之前执行的，而不是之后（无论定时器位置在sampler之前还是下面）；
	（2）当执行一个sampler之前时，所有当前作用域内的定时器都会被执行；
	（3）如果希望定时器仅应用于其中一个sampler，则把定时器作为子节点加入；
	（4）如果希望在sampler执行完之后再等待，则可以使用Test Action；

2、定时器之固定定时器（Constant Timer）
	业务逻辑：使得在开始某请求或全部请求之前等待一个固定时间
	使用场景：（1）如果要在开始某请求前等待一个固定的时间，就将Constant-Timer放到该请求下面（该请求中）
		     （2）如果要在开始所有的请求之前等待一个固定的时间，就将Constant-Timer放到所有请求的最前面或者最后面，如果Constant-Timer不放在请求中，那么无论放在哪里，都会先执行Constant-Timer，再去执行请求
3、高斯随机定时器（Gaussian Random Timer）
	业务逻辑：如需要每个线程在请求前按随机时间停顿，那么使用这个定时器，偏差：100.0，固定延迟偏移：300，表示暂停时间会分布在100到400之间。
	总延迟时间=高斯分布值（平均0.0和标准偏差1.0）*指定的偏差值+固定延迟偏移，计算公式参考：Math.abs((this.random.nextGaussian() * 300) + 100)
	另一种解释方法，在高斯随机定时器中， 随机时间在固定延迟偏移附近，概率符合高斯曲线分布。

4、均匀随机定时器（Uniform Random Timer）
	和高斯随机定时器的作用差异不大，区别在于延时时间在指定范围内且每个时间的取值概率相同，每个时间间隔都有相同的概率发生，总的延迟时间就是随机值和偏移值之和。
	下面表示的是随机延迟时间的最大值是100毫秒：
	（1）Random Delay Maximum(in milliseconds):随机延迟时间的最大毫秒数
	（2）Constant Delay Offset(in milliseconds):暂停的毫秒数减去随机延迟的毫秒数

5、常数吞吐量定时器（Constant Throughput Timer）控制给定的取样器发送请求的吞吐量
	1、原理：默认情况下，Jmeter线程在发送请求之间没有间歇。建议为线程组添加某种定时器，以便设定请求之间应该间隔多长时间。如果测试人员不设定这种延迟，Jmeter可能会短时间内产生大量访问请求，导致服务器被大量请求所淹没。定时器会让作用域内的每一个采样器都在执行前等待一个固定时长。如果测试人员为线程组添加了多个定时器，那么Jmeter会将这些定时器的时长叠加起来，共同影响作用域范围内的采样器，定时器可以作为采样器或者逻辑控制器的子项，目的是只影响作用域内的采样器。
	2、Constant Throughput Timer常数吞吐量定时器可以让Jmeter以指定数字的吞吐量（即指定TPS，只是这里要求每分钟的执行数，而不是每秒）执行。吞吐量计算的范围可以指定为当前线程、当前线程组、所有线程组，并且计算吞吐量的依据可以是最近一次线程的执行延迟。

6、同步定时器
	这个定时器和loadrunner当中的集合点（rendezvous-point）作用相似，其作用是：阻塞线程，直到指定的线程数量到达后，再一起释放，可以瞬间产生很大的压力（人多力量大- -哈哈！）
	（1）Number of Simulated Users to Group by:模拟用户的数量，即指定同时释放的线程数数量
	（2）Timeout in milliseconds:超时时间，即超时多少毫秒后同时释放指定的线程数

7、BeanShell定时器（BeanShell Timer）


8、泊松随机定时器（Poisson Random Timer）
	这个定时器在每个线程请求之前按随机的时间停顿，大部分的时间间隔出现在一个特定的值，总的延迟就是泊松分布值和偏移值之和。
	（1）Lambda(in milliseconds):兰布达值
	（2）Constant Delay Offset(in milliseconds):暂停的毫秒数减去随机延迟的毫秒数
	如果Lambda设置100(in milliseconds)，Constant-Delay-Offset(in milliseconds)
	设置300，表示暂停时间会在100到400毫秒之间分布

9、JSR223定时器（JSR223 Timer）

10、BSF定时器（BSF Timer）

五、控制器

可以对元件的执行逻辑进行控制，除仅一次控制器外，其他控制器下可以嵌套别的种类的逻辑控制器。

1、If Controller【如果（If）控制器】
	如果（If）控制器：
	1、条件控制器，可以通过某个条件来控制此节点下的元件是否运行；条件可以使用 JavaScript 与变量表达式。
	2、允许用户控制该控制器下面的取样器/控制器是否执行该节点下的子节点。
	 
	// ************************* 【如果（If）控制器】 参数说明 ************************* //
	1、名称：如果（If）控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Expression(must evaluate to true or false)：
	表达式（必须计算为true或false）
	（1）Interpret Condition as Variable Expression？：
	条件是否解释为变量表达式？
	[默认勾选：是，那么变量表达式会进行求值，并与“ture”或“false”进行比较，而无需使用JavaScript；
	不勾选：否]
	（2）Evaluate for all children？：
	判断条件是否对所有的子节点执行？
	[勾选：是，则该条件在每一个子节点执行时执行一次；
	默认不勾边：否，该控制器可以对包含在其下面的所有可运行的元素进行执行，但只在如果（If）控制器的入口处判断一次。]
	 
	4、说明翻译：
	For performance it is advised to check "Interpret Condition as Variable Expression" and 
	use __jecl3 or __groovy evaluating to true or false or a variable that contains true or false.
	对于性能，建议检查“将条件解释为变量表达式”，并使用“jecl3”或“groovy”计算为“真”或“假”或包含“真”或“假”的变量。
	 
	${JmeterThread.last_sample_ok} can be used to test if last sample was successful
	${JmeterThread.last_sample_ok}：可用于测试最后一个样本是否成功
2、Transaction Controller【事务控制器】
	事务控制器：
	1、生成一个额外的采样器来测量其下测试元素的总体时间；
	值得注意的是，这个时间包含该控制器范围内的所有处理时间，而不仅仅是采样器的.
	2、事务响应时间是我们衡量业务性能的主要指标，事务控制器可以把其节点下的取样器执行消耗时间累加在一起，便于我们统计。
	3、同时我们对每一个取样器的执行时间进行统计。
	4、如果事务控制器下的取样器有多个，那么只有每一个取样器都运行成功了，整个事务控制器定义的事务才算成功，这是充分必要条件。
	 
	// ************************* 【事务控制器】 参数说明 ************************* //
	1、名称：事务控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Generate Parent sample：
	是否生成父样本
	[勾选：是；默认不勾选：否]
	 
	4、Include duration oftimer and pre-post processors in generated sample: 
	是否在生成的样本中，包括计时器和前后处理程序的持续时间，即是否在取样器前与后加上延时
	[勾选：是；默认不勾选：否]
	// 建议大家不用勾选这个选项，不然统计就比较麻烦了，还需要扣除延时。 


3、Loop Controller【循环控制器】
	循环控制器：循环控制器可以控制在其节点下的元件的执行次数，该控制器下的取样器请求可以循环运行。
	 
	// ********************* 【循环控制器】 执行次数计算规则 ******************** //
	如果在线程组中也设置了执行次数，那么循环控制器下的元件的执行次数是:
	循环控制器下的元件的执行次数 = 线程组执行次数 * 循环控制器执行次数
	 
	例如：线程组设置执行 3 次，循环控制器设置执行 6 次，那么其下的元件执行次数为 18 次。
	 
	 
	// ************************* 【循环控制器】 参数说明 ************************* //
	1、名称：循环控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、循环次数：
	永远：是否设置为永久循环
	[勾选：是，那么控制器下的请求可一直运行；
	默认不勾选且循环次数为1：否，填写具体的执行次数，在输入框中输入需要循环的次数，控制器下的请求即可循环运行]

4、 While Controller【While 控制器】
	While 控制器：While 条件控制器，当/判断控制器，其节点下的元件将一直运行直到 While 条件为 false 。
	 
	// ************************* 【While 控制器】 参数说明 ************************* //
	1、名称：While 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Condition(function or variable)：
	条件（函数或变量）
	[填写：里面可填入判断依据的条件，接受变量表达式与变量]
	 
	 
	// **************** 【Condition(function or variable)】 三个常量 **************** //
	1、Blank：空白，当循环中有取样器失败后停止。
	2、LAST: 最后一个值，当循环前有取样器失败则不进入循环。
	3、Otherwise: 否则，当判断条件为 false 时停止循环。
	// 条件可以是任何变量或函数，最终等于字符串” 假 ”。
	// 需要注意的是：条件是评估两次,一次取样前,一次随机取样

5、Critical Section Controller【临界部分控制器】
	临界部分控制器：
	1、确保它的子元素(取样器/控制器等)在执行控制器的子程序之前，只执行一个线程作为指定的锁。
	2、确保其子节点下的取样器或控制器将被执行（只有一个线程作为一个锁）。
	 
	// ************************* 【临界部分控制器】 参数说明 ************************* //
	1、名称：临界部分控制器名称，可以随意设置，甚至可以为空。 
	2、注释：可以随意设置，可以为空。 
	3、Lock name：锁名
	最好作为唯一值，这里可以填入其子节点下执行的线程的名称，这个线程作为一个全局锁存在
	[默认填写：global_lock（全局锁）]

	又叫临界区控制器Critical Section Controller
	业务逻辑：根据锁名来控制并发，同一个锁名之下，在同一时间点只能存在一个运行中，适用于控制并发的场景（控制请求之间顺序执行）
	锁名类型：锁名为空，认为每个锁为不同的锁
			 锁名相同，多个锁认为是同一个锁，同一个时间点只能存在一个运行中
             锁名为变量，根据变量值来判断是不是属于同一个锁，变量值为相同时，则认为是同一个锁
    使用场景：线程组设置并发数100或循环次数100次，临界区控制器下的采样器，是按照顺序执行的，可见此控制器的作用

6、ForEach Controller 【ForEach 控制器】
	ForEach 控制器：
	1、即遍历循环控制器，顾名思义是定义一个循环规则。
	2、用来遍历当前元素的所有可执行场景。
	3、在用户自定义变量中读取一系列相关的变量，该控制器下的采样器或控制器都会被执行一次或多次，每次读取不同的变量值。
	4、这个控制器一般配合配置元件 → 正则表达式提取器来一起使用，可对页面上的某些元素进行重复处理。
	 
	// ************************* 【ForEach 控制器】 参数说明 ************************* //
	1、名称：While 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、输入变量前缀：
	（1）在其中输入需要遍历的用户参数
	（2）可以在"用户自定义的变量"中定义一组变量，ForEach 控制器可以从中获取到变量对应的值，
	然后作为 ForEach 控制器的循环条件，还可以输出变量作为取样器的参数。
	 
	4、开始循环字段（不包含）: 循环变量下标起点。
	循环指数开始（唯一）→ 遍历查询的变量范围，开始的值
	（这里如果不填写，默认从 1 开始，如果没有 1 开始的变量，执行时会报错）
	 
	5、结束循环字段（包含）: 循环变量下标终点。 
	循环指数结束（包含）→ 遍历查询的变量范围，结束的值
	 
	6、输出变量名称：ForEach 控制器生成的变量名称。
	将遍历查询到的符合条件的用户参数赋值给输入变量（Vname），然后就可以在控制器下的取样器使用，
	格式为：${输出变量名}
	 
	7、Add "_" before number?: 
	输入变量名称中，变量前缀后是否加 "_" 作为分隔符？
	[默认勾选：是；不勾选：否]

7、Include Controller【Include 控制器】
	Include 控制器：
	1、包含控制器，用于引用外部的Jmx文件、导入外部的测试片段(非完整的测试计划)；
	从而控制多个测试计划组合，在执行时会执行导入的测试计划。
	2、但是被导入的测试计划有特殊要求，它不能有线程组，只能包含简单控制器及控制器下的元件。
	3、简单点说就是相当于加了一个执行单元，一个封装了的业务操作单元，类似我们程序开发中的函数一样。
	4、比如一个查询订单的业务操作我们用取样器来模拟，然后放到简单控制器中作为一个执行单元，
	别的地方也要用到时，我们可以不重写直接引用过来，这就类似我们 Java 开发中的方法封装。
	 
	// ************************* 【Include 控制器】 参数说明 ************************* //
	1、名称：Include 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、文件名：必输字段，如果没有则会报错。
	包含测试计划的文件名，可以点击浏览，从文件夹保存的 JMX 文件夹目录下选择对应的 JMX 文件。
	 
	 
	// ************************* 【Include 控制器】 使用方法 ************************* //
	1、创建一个测试计划，下面可添加取样器/控制器等，然后保存测试计划，为了方便起见, 
	线程组也可以添加外部JMX文件中用于调试；
	 
	2、如果测试使用Cookie或用户定义的变量,这些应放置在顶层（包括文件）,否则无法正常工作；
	此元素不支持变量/函数在文件名字段中；但是,如果属于包含控制器定义的内容，则使用前缀路径名。
	 
	3、当使用包含控制器中包含相同的JMX文件,则要确保文件名不同,以避免无法读取；
	如果文件不能被发现，那么控制器会尝试打开文件名相对于JMX启动目录。

8、Interleave Controller【交替控制器】
	交替控制器：交替控制器，其节点下的取样器会交替执行，使得该控制器包含的取样器步骤交错执行在每个循环中
	 
	// ************************* 【交替控制器】 参数说明 ************************* //
	1、名称：交替控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、忽略资控制器块：jmeter 汉化错别字，应为——忽略子控制器模块
	忽略子控制器，即子控制器失效，由交替控制器接管。
	[勾选：如果勾选此项,交替控制器将子控制器像单一请求元素一样，一次只允许一个请求/控制器；
	默认不勾选：否]
	 
	4、Interleave across threads：是否跨线程交错
	[勾选：是；默认不勾选：否]
	 
	// ************************* 【交替控制器】 使用方法 ************************* //
	假使该控制器下有2个取样器 A 和 B ，交替执行 A 和 B 2个请求，即每次传递一个子请求到这个测试，按子元件的排列顺序。

9、Once Only Controller【仅一次控制器】
	仅一次控制器：
	1、在多线程循环的时候，将使其子节点下的取样器请求只运行一次。
	2、也就是此控制器下的子元件只运行一次，即使把仅一次控制器放在循环控制器下面，也只是运行一次。
	3、我们在模拟请求时有时只需要登录一次，就可以把登录的部分放在仅一次控制器下。
	 
	// ************************* 【仅一次控制器】 参数说明 ************************* //
	1、名称：仅一次控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

10、Random Controller【随机控制器】
	随机控制器：
	1、类似交替控制器，但该控制器随机选取某一个取样器请求并执行。
	2、随机控制器节点下的元件随机运行，与交替控制器不一样的是节点下的元件运行顺序不定。
	 
	// ************************* 【随机控制器】 参数说明 ************************* //
	1、名称：随机控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、忽略资控制器块：jmeter 汉化错别字，应为——忽略子控制器模块
	忽略子控制器，即子控制器失效，由随机控制器接管。
	[勾选：如果勾选此项,随机控制器将子控制器像单一请求元素一样，一次只允许一个请求/控制器；
	默认不勾选：否]

11、Random Order Controller【随机顺序控制器】
	随机顺序控制器：
	1、类似于简单控制器，将执行每个子节点下的取样器请求一次，但是执行是随机的。
	2、其节点下的元件随机执行，不过每个元件只执行一次。
	 
	// ************************* 【随机顺序控制器】 参数说明 ************************* //
	1、名称：随机顺序控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

12、Recording Controller【录制控制器】
	录制控制器：
	1、顾名思义是录制的时候用到的，类似代理服务器的作用，在测试执行期间记录测试样本。
	2、实际上它是一个位置，当我们用 JMeter 代理进行录制时，录制的脚本默认放在此控制器的节点下面。
	3、没有实际的逻辑作用，我们用简单控制器也可以代替它。
	 
	// ************************* 【录制控制器】 参数说明 ************************* //
	1、名称：录制控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Clear all the recorded samples：清除所有记录的样本
	[点击可以清除所有已经记录的测试样本]

13、Runtime Controller【Runtime 控制器】
	Runtime 控制器：生命周期/运行周期控制器，用来控制其子元件的执行时长，时长的单位是秒。
	 
	// ************************* 【Runtime 控制器】 参数说明 ************************* //
	1、名称：Runtime 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Runtime (seconds): 执行时长（运行时间）
	[默认为 1 ；去掉 1 则默认为 0 ，此时不执行其节点下的元件；其他自定义修改数字。]

14、Simple Controller【简单控制器】
	简单控制器：
	1、用来指定了一个执行单元，它不改变元件的执行顺序。
	2、在简单控制器下面还可以嵌套其他控制器。
	3、简单控制器是最基本的控制器，对jmeter测试运行没有任何影响，可用来命名某些操作。
	 
	// ************************* 【简单控制器】 参数说明 ************************* //
	1、名称：简单控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

15、jp@gc - Parameterized Controller
	jp@gc - Parameterized Controller：
	1、jp@gc - 参数化控制器，可以通过JMeter插件来监控服务器CPU、内存、磁盘、网络等相关资源。
	2、安装服务器监控插件后，此控制器才会出现：
	其中 JMeterPlugins-Standard 和 JMeterPlugins-Extras 是客户端的，ServerAgent 是服务端的。
	 
	// ****************** 【jp@gc - Parameterized Controller】 参数说明 ****************** //
	1、名称：jp@gc - Parameterized Controller名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Help on this plugin ：关于此插件的帮助
	[点击查看官方说明文档]
	 
	4、用户定义的变量
	（1）名称：用户定义的所有变量的总名称，可以随意设置，甚至可以为空。 
	（2）注释：可以随意设置，可以为空。 
	（3）列表：
	● 名称：用户定义的变量名
	● 值：用户定义的变量值
	● Description：描述
	[按钮：详细、添加、从剪切板添加、删除、向下、向上]

16、Throughput Controller【吞吐量控制器】
	吞吐量控制器：
	1、应该译为：流量控制器，jmeter自带的翻译这里是错误的，因为它并不能控制吞吐量。
	2、吞吐量控制器，用来控制其下元件的执行次数，并无控制吞吐量的功能，
	其实质作用是允许用户控制执行的频率。
	3、想要控制吞吐量可以使用定时器： Constant Throughput Timer 。
	4、吞吐量控制器有两种模式: Total Executions 与 Percent Executions 。
	 
	// ************************* 【吞吐量控制器】 参数说明 ************************* //
	1、名称：吞吐量控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、下拉框：吞吐量控制器模式二选一
	（1）Percent Executions [默认]：执行百分比
	● 使控制器按一定比例执行迭代的测试计划
	● 按执行次数的百分比来计算执行次数，此时“吞吐量”取值是 0~100 。
	（2）Total Executions：总执行次数
	● 使控制器停止执行一定数量的测试计划
	● 按 Throughput 的值来指定执行次数，此时“吞吐量”可以是任意整数，如果小于等于零则一次也不执行。
	 
	4、吞吐量：流量
	（1）Percent Executions 模式下：执行百分比，取值是 0~100
	（2）Total Executions 模式下：总执行次数，任意整数
	 
	5、Per User：是否所有虚拟用户
	（1）Percent Executions 模式下：Per User 是否勾选对此模式无影响。
	（2）Total Executions 模式下：此时 Per User 与 Total Executions一起来影响执行次数。
	[勾选：是，按虚拟用户数来计算执行次数；默认不勾选：否，按所有虚拟用户来计算执行次数]

17、Module Controller【模块控制器】
	模块控制器：可以通过模块控制器在当前测试计划中引入新的测试片段（也可以叫脚本片段，由控制器、
	取样器及辅助元件构成，能够完成负载的模拟）。
	 
	// ************************* 【模块控制器】 参数说明 ************************* //
	1、名称：模块控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、Find target element：查找目标元素
	寻找测试计划中需要特定测试的元素、模块，也可理解为该控制器可以控制已经封装好的模块元素
	[点击此按钮，再点击 “Module To Run” 下的原件，模块控制器会直接切换跳转到该元件。
	不点击此按钮，点击 “Module To Run” 下的原件，依旧停留在模块控制器。]
	 
	4、Module To Run: 模块运行下拉列表
	列出了测试计划及工作台包含的控制器，在此选择需要引入其中的一个脚本片段。
	 
	 
	// *************************** 【模块控制器】 作用 *************************** //
	● 一个测试计划由一个控制器和所有的测试元素（取样器等）组成，测试计划可以位于任何线程组或工作台；
	如果计划位于线程组，则可以禁用其他控制器，防止正在运行的测试计划被影响（除了模块控制器）
	 
	● 模块控制器的优势在于：当存在多个线程组时，该控制器可以轻松切换，只需要选择对应的取样器，
	方便快捷，替代了创建很多测试计划的繁琐操作
	 
	● 任何一个模块所用的控制器名字必须唯一，因为其名字被用来找到目标控制器时重新加载；
	出于这个原因，最好保证控制器名字不同，否则执行测试时候可能发生意外
	 
	● 模块控制器与远程测试不应使用或非gui测试与工作台部件，因为工作台测试元素并没有测试计划的
	一部分 jmx 文件，任何这样的测试就会失败。

18、Switch Controller【Switch 控制器】
	Switch 控制器：
	1、Switch 条件控制器，转换控制器，类似于高级语言中的 Switch 逻辑控制语句，
	通过给该控制器中的 value 赋值，来指定运行哪个取样器（也可以理解为开关控制器）。
	2、例如指定运行的取样器编号为 0 (JMeter 会给节点下的取样器顺序编号，第一个取样器 "Java 请求"编号为 0 ，
	第二个取样器"Java 请求 2" 的编号就是 1 ，所以这里指定 0 就会运行第一个 Java 请求)。
	3、如果指定的编号超出了下面的节点数或者不指定，则运行第 0 个取样器。
	4、也可以指定取样器的名称，名称匹配时大小写及空格都敏感，如果匹配不上则不运行取样器。
	 
	// ************************* 【Switch 控制器】 参数说明 ************************* //
	1、名称：Switch 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、Switch Value：控制器具体赋值的 value 值字段
	（1）第一种是数值：Switch控制器下的子节点从0开始计数，通过指定子节点所在的数值来确定执行哪个元素。
	（2）第二种是字符：直接指定子元素的名称，比如取样器名称来进行匹配。
	● 当指定的名称不存在时，不执行任何元素。
	● 当 Value 为空时，默认执行第 1 个子节点元素。




流量指标-互联网的数据术语（VV UV PV IP）

1、来访次数/访问次数(VV)：VV = VisitView(访问次数)：记录所有访客1天内访问了多少次你的网站，相同的访客有可能多次访问您的网站。从访客来到您网站到最终关闭网站的所有页面离开，计为1次访问。若访客连续30分钟没有新开和刷新页面，或者访客关闭了浏览器，则被计算为本次访问结束。那么上图A就是从搜索词“宫外孕有什么症状”进入网站的访问次数329.

2、独立访客(UV)：1天内相同访客多次访问网站，只计算为1个独立访客。上图数据就是1天内从搜索词“宫外孕有什么症状”进入网站的独立访客294.

3、浏览次数(PV)：即通常说的PV(PageView)值，用户每打开1个网站页面，记录1个PV。用户多次打开同一页面PV累计多次。用以衡量网站用户访问的网页数量。上图数据意思从搜索词“宫外孕有什么症状”进入网站的访客浏览次数是360.

4、独立IP数：1天(00:00-24:00)之内，访问网站的不重复IP数。一天内相同IP地址多次访问网站只被计算1次。同一IP无论访问了几个页面，独立IP数均为1访问次数，

一、性能测试影响因素
1、响应时间：对请求作出相应所需要的时间
  	网络传输时间：N1+N2+N3+N4
  	应用服务器处理时间：A1+A3
  	数据库服务器处理时间：A2
  	响应时间：N1+N2+N3+N4+A1+A3+A2
2、并发用户数的计算公式
	系统用户数：系统额定的用户数量
	同时在线用户数：在一定时间范围内，最大的同时在线用户数量
	平均并发用户数的计算：C = nl/T
		其中，C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session）的平均时间，T是考察时间长度（一天内多长时间用户使用系统）
	并发用户数峰值计算：C^约等于C+3*√C
		其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论
3、吞吐量计算公式
	当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU*R/T
	其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T代表性能测试所用的时间
4、性能计数器
	资源利用率：指系统各种资源的使用情况，如CPU占用率为68%，内存占用率55%，一般使用“资源实际使用/总的资源可用量，形成资源利用率
	性能计数器是描述服务器或操作系统性能的一些数据指标
5、思考时间的计算公式
	Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做性能测试的时候，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。
	在吞吐量这个公式中,(F=VU*R/T)说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R=T/TS

二、高并发性能指标QPS、TPS、RT、并发数、吞吐量、吞吐量详解
1、QPS，每秒查询
QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。（每秒钟处理完的请求次数，注意这里是处理完）

2、TPS，每秒事务
TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。

3、RT，响应时间
响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。

4、并发数
并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。

5、吞吐量
系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。

QPS（TPS）：（Query Per Second）每秒钟request/事务 数量
并发数： 系统同时处理的request/事务数
响应时间： 一般取平均响应时间
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间
并发数 = QPS*平均响应时间

6、实际举例
我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20%时间就叫做峰值时间。
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器
（1）、每天300w PV 的在单台机器上，这台机器需要多少QPS？ 
	( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)

（2）、如果一台机器的QPS是58，需要几台机器来支持？ 
	139 / 58 = 3

7、最佳线程数、QPS、RT
（1）、单线程QPS公式：QPS=1000ms/RT
	对同一个系统而言，支持的线程数越多，QPS越高。假设一个RT是80ms,则可以很容易的计算出QPS,QPS = 1000/80 = 12.5
	多线程场景，如果把服务端的线程数提升到2，那么整个系统的QPS则为 2*（1000/80） = 25, 可见QPS随着线程的增加而线性增长，那QPS上不去就加线程呗，听起来很有道理，公司也说的通，但是往往现实并非如此。

（2）、QPS和RT的真实关系
	我们想象的QPS、RT关系是随着RT的逐渐增大，QPS逐渐降低的凹曲线
	实际的QPS、RT关系是随着RT的逐渐增大，QPS逐渐降低的凸曲线

（3）、最佳线程数量
	刚好消耗完服务器的瓶颈资源的临界线程数，公式如下
	最佳线程数量=（（线程等待时间+线程cpu时间）/线程cpu时间）* cpu数量
	特性：
	在达到最佳线程数的时候，线程数量继续递增，则QPS不变，而响应时间变长，持续递增线程数量，则QPS开始下降。
	每个系统都有其最佳线程数量，但是不同状态下，最佳线程数量是会变化的。
	瓶颈资源可以是CPU,可以是内存，可以是锁资源，IO资源：超过最佳线程数-导致资源的竞争，超过最佳线程数-响应时间递增。


三、Jmeter仅一次控制器Once only Controller使用案例
1、Once-only-Controller仅一次控制器，它下面的原件只会运行一次。即使Once-only-Controller是在循环控制器下，也只会运行一次
2、场景
	多个并发用户，每个用户需要先登录，而且只需要登录一次，每个并发登录成功后，会产生一个accessToken，也就是代表了登录服务端登录鉴权通过后，返回给请求调用的一个标志，在后面具体的Http接口请求中，每个并发用户都需要在请求中传入这个accessToken，不然的话，服务端的鉴权就是失败。
3、压测脚本设置
	（1）在线程组添加Once only Controller，在Once only Controller下添加Http请求（登录）
		登录请求在Once only Controller下至可循环一次（做数据驱动时），如线程组数量为5，循环次数为10，仅一次控制器（Once only Controller）下有个Http请求采样器，在查看结果树下只有5次返回结果。
	（2）然后将登录的cookies传给下一个接口，此时，在查看结果树下，查看登录接口的响应数据中的Response headers，在头信息中会有set-cookies，得到set-cookies之后，在登录请求后添加正则表达提取器将set-cookies的值提取出来，使用正则表达式【set-cookies:(.*)】，然后将cookies值提取出来，提取成功之后，添加BeanShell PostProcessor，将cookies值传入下一个接口。
4、补充
	（1）在添加正则表达提取器之后，可以添加“调试取样器（Debug Sampler）“验证提取的数据是否成功
	（2）接口走通之后，便可以做数据驱动

四、定时器详解
1、定时器的作用域
	（1）定时器是在每个sampler（采样器）之前执行的，而不是之后（无论定时器位置在sampler之前还是下面）；
	（2）当执行一个sampler之前时，所有当前作用域内的定时器都会被执行；
	（3）如果希望定时器仅应用于其中一个sampler，则把定时器作为子节点加入；
	（4）如果希望在sampler执行完之后再等待，则可以使用Test Action；

2、定时器之固定定时器（Constant Timer）
	业务逻辑：使得在开始某请求或全部请求之前等待一个固定时间
	使用场景：（1）如果要在开始某请求前等待一个固定的时间，就将Constant-Timer放到该请求下面（该请求中）
		     （2）如果要在开始所有的请求之前等待一个固定的时间，就将Constant-Timer放到所有请求的最前面或者最后面，如果Constant-Timer不放在请求中，那么无论放在哪里，都会先执行Constant-Timer，再去执行请求
3、高斯随机定时器（Gaussian Random Timer）
	业务逻辑：如需要每个线程在请求前按随机时间停顿，那么使用这个定时器，偏差：100.0，固定延迟偏移：300，表示暂停时间会分布在100到400之间。
	总延迟时间=高斯分布值（平均0.0和标准偏差1.0）*指定的偏差值+固定延迟偏移，计算公式参考：Math.abs((this.random.nextGaussian() * 300) + 100)
	另一种解释方法，在高斯随机定时器中， 随机时间在固定延迟偏移附近，概率符合高斯曲线分布。

4、均匀随机定时器（Uniform Random Timer）
	和高斯随机定时器的作用差异不大，区别在于延时时间在指定范围内且每个时间的取值概率相同，每个时间间隔都有相同的概率发生，总的延迟时间就是随机值和偏移值之和。
	下面表示的是随机延迟时间的最大值是100毫秒：
	（1）Random Delay Maximum(in milliseconds):随机延迟时间的最大毫秒数
	（2）Constant Delay Offset(in milliseconds):暂停的毫秒数减去随机延迟的毫秒数

5、常数吞吐量定时器（Constant Throughput Timer）控制给定的取样器发送请求的吞吐量
	1、原理：默认情况下，Jmeter线程在发送请求之间没有间歇。建议为线程组添加某种定时器，以便设定请求之间应该间隔多长时间。如果测试人员不设定这种延迟，Jmeter可能会短时间内产生大量访问请求，导致服务器被大量请求所淹没。定时器会让作用域内的每一个采样器都在执行前等待一个固定时长。如果测试人员为线程组添加了多个定时器，那么Jmeter会将这些定时器的时长叠加起来，共同影响作用域范围内的采样器，定时器可以作为采样器或者逻辑控制器的子项，目的是只影响作用域内的采样器。
	2、Constant Throughput Timer常数吞吐量定时器可以让Jmeter以指定数字的吞吐量（即指定TPS，只是这里要求每分钟的执行数，而不是每秒）执行。吞吐量计算的范围可以指定为当前线程、当前线程组、所有线程组，并且计算吞吐量的依据可以是最近一次线程的执行延迟。

6、同步定时器
	这个定时器和loadrunner当中的集合点（rendezvous-point）作用相似，其作用是：阻塞线程，直到指定的线程数量到达后，再一起释放，可以瞬间产生很大的压力（人多力量大- -哈哈！）
	（1）Number of Simulated Users to Group by:模拟用户的数量，即指定同时释放的线程数数量
	（2）Timeout in milliseconds:超时时间，即超时多少毫秒后同时释放指定的线程数

7、BeanShell定时器（BeanShell Timer）


8、泊松随机定时器（Poisson Random Timer）
	这个定时器在每个线程请求之前按随机的时间停顿，大部分的时间间隔出现在一个特定的值，总的延迟就是泊松分布值和偏移值之和。
	（1）Lambda(in milliseconds):兰布达值
	（2）Constant Delay Offset(in milliseconds):暂停的毫秒数减去随机延迟的毫秒数
	如果Lambda设置100(in milliseconds)，Constant-Delay-Offset(in milliseconds)
	设置300，表示暂停时间会在100到400毫秒之间分布

9、JSR223定时器（JSR223 Timer）

10、BSF定时器（BSF Timer）

五、控制器

可以对元件的执行逻辑进行控制，除仅一次控制器外，其他控制器下可以嵌套别的种类的逻辑控制器。

1、If Controller【如果（If）控制器】
	如果（If）控制器：
	1、条件控制器，可以通过某个条件来控制此节点下的元件是否运行；条件可以使用 JavaScript 与变量表达式。
	2、允许用户控制该控制器下面的取样器/控制器是否执行该节点下的子节点。
	 
	// ************************* 【如果（If）控制器】 参数说明 ************************* //
	1、名称：如果（If）控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Expression(must evaluate to true or false)：
	表达式（必须计算为true或false）
	（1）Interpret Condition as Variable Expression？：
	条件是否解释为变量表达式？
	[默认勾选：是，那么变量表达式会进行求值，并与“ture”或“false”进行比较，而无需使用JavaScript；
	不勾选：否]
	（2）Evaluate for all children？：
	判断条件是否对所有的子节点执行？
	[勾选：是，则该条件在每一个子节点执行时执行一次；
	默认不勾边：否，该控制器可以对包含在其下面的所有可运行的元素进行执行，但只在如果（If）控制器的入口处判断一次。]
	 
	4、说明翻译：
	For performance it is advised to check "Interpret Condition as Variable Expression" and 
	use __jecl3 or __groovy evaluating to true or false or a variable that contains true or false.
	对于性能，建议检查“将条件解释为变量表达式”，并使用“jecl3”或“groovy”计算为“真”或“假”或包含“真”或“假”的变量。
	 
	${JmeterThread.last_sample_ok} can be used to test if last sample was successful
	${JmeterThread.last_sample_ok}：可用于测试最后一个样本是否成功
2、Transaction Controller【事务控制器】
	事务控制器：
	1、生成一个额外的采样器来测量其下测试元素的总体时间；
	值得注意的是，这个时间包含该控制器范围内的所有处理时间，而不仅仅是采样器的.
	2、事务响应时间是我们衡量业务性能的主要指标，事务控制器可以把其节点下的取样器执行消耗时间累加在一起，便于我们统计。
	3、同时我们对每一个取样器的执行时间进行统计。
	4、如果事务控制器下的取样器有多个，那么只有每一个取样器都运行成功了，整个事务控制器定义的事务才算成功，这是充分必要条件。
	 
	// ************************* 【事务控制器】 参数说明 ************************* //
	1、名称：事务控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Generate Parent sample：
	是否生成父样本
	[勾选：是；默认不勾选：否]
	 
	4、Include duration oftimer and pre-post processors in generated sample: 
	是否在生成的样本中，包括计时器和前后处理程序的持续时间，即是否在取样器前与后加上延时
	[勾选：是；默认不勾选：否]
	// 建议大家不用勾选这个选项，不然统计就比较麻烦了，还需要扣除延时。 


3、Loop Controller【循环控制器】
	循环控制器：循环控制器可以控制在其节点下的元件的执行次数，该控制器下的取样器请求可以循环运行。
	 
	// ********************* 【循环控制器】 执行次数计算规则 ******************** //
	如果在线程组中也设置了执行次数，那么循环控制器下的元件的执行次数是:
	循环控制器下的元件的执行次数 = 线程组执行次数 * 循环控制器执行次数
	 
	例如：线程组设置执行 3 次，循环控制器设置执行 6 次，那么其下的元件执行次数为 18 次。
	 
	 
	// ************************* 【循环控制器】 参数说明 ************************* //
	1、名称：循环控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、循环次数：
	永远：是否设置为永久循环
	[勾选：是，那么控制器下的请求可一直运行；
	默认不勾选且循环次数为1：否，填写具体的执行次数，在输入框中输入需要循环的次数，控制器下的请求即可循环运行]

4、 While Controller【While 控制器】
	While 控制器：While 条件控制器，当/判断控制器，其节点下的元件将一直运行直到 While 条件为 false 。
	 
	// ************************* 【While 控制器】 参数说明 ************************* //
	1、名称：While 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Condition(function or variable)：
	条件（函数或变量）
	[填写：里面可填入判断依据的条件，接受变量表达式与变量]
	 
	 
	// **************** 【Condition(function or variable)】 三个常量 **************** //
	1、Blank：空白，当循环中有取样器失败后停止。
	2、LAST: 最后一个值，当循环前有取样器失败则不进入循环。
	3、Otherwise: 否则，当判断条件为 false 时停止循环。
	// 条件可以是任何变量或函数，最终等于字符串” 假 ”。
	// 需要注意的是：条件是评估两次,一次取样前,一次随机取样

5、Critical Section Controller【临界部分控制器】
	临界部分控制器：
	1、确保它的子元素(取样器/控制器等)在执行控制器的子程序之前，只执行一个线程作为指定的锁。
	2、确保其子节点下的取样器或控制器将被执行（只有一个线程作为一个锁）。
	 
	// ************************* 【临界部分控制器】 参数说明 ************************* //
	1、名称：临界部分控制器名称，可以随意设置，甚至可以为空。 
	2、注释：可以随意设置，可以为空。 
	3、Lock name：锁名
	最好作为唯一值，这里可以填入其子节点下执行的线程的名称，这个线程作为一个全局锁存在
	[默认填写：global_lock（全局锁）]

	又叫临界区控制器Critical Section Controller
	业务逻辑：根据锁名来控制并发，同一个锁名之下，在同一时间点只能存在一个运行中，适用于控制并发的场景（控制请求之间顺序执行）
	锁名类型：锁名为空，认为每个锁为不同的锁
			 锁名相同，多个锁认为是同一个锁，同一个时间点只能存在一个运行中
             锁名为变量，根据变量值来判断是不是属于同一个锁，变量值为相同时，则认为是同一个锁
    使用场景：线程组设置并发数100或循环次数100次，临界区控制器下的采样器，是按照顺序执行的，可见此控制器的作用

6、ForEach Controller 【ForEach 控制器】
	ForEach 控制器：
	1、即遍历循环控制器，顾名思义是定义一个循环规则。
	2、用来遍历当前元素的所有可执行场景。
	3、在用户自定义变量中读取一系列相关的变量，该控制器下的采样器或控制器都会被执行一次或多次，每次读取不同的变量值。
	4、这个控制器一般配合配置元件 → 正则表达式提取器来一起使用，可对页面上的某些元素进行重复处理。
	 
	// ************************* 【ForEach 控制器】 参数说明 ************************* //
	1、名称：While 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、输入变量前缀：
	（1）在其中输入需要遍历的用户参数
	（2）可以在"用户自定义的变量"中定义一组变量，ForEach 控制器可以从中获取到变量对应的值，
	然后作为 ForEach 控制器的循环条件，还可以输出变量作为取样器的参数。
	 
	4、开始循环字段（不包含）: 循环变量下标起点。
	循环指数开始（唯一）→ 遍历查询的变量范围，开始的值
	（这里如果不填写，默认从 1 开始，如果没有 1 开始的变量，执行时会报错）
	 
	5、结束循环字段（包含）: 循环变量下标终点。 
	循环指数结束（包含）→ 遍历查询的变量范围，结束的值
	 
	6、输出变量名称：ForEach 控制器生成的变量名称。
	将遍历查询到的符合条件的用户参数赋值给输入变量（Vname），然后就可以在控制器下的取样器使用，
	格式为：${输出变量名}
	 
	7、Add "_" before number?: 
	输入变量名称中，变量前缀后是否加 "_" 作为分隔符？
	[默认勾选：是；不勾选：否]

7、Include Controller【Include 控制器】
	Include 控制器：
	1、包含控制器，用于引用外部的Jmx文件、导入外部的测试片段(非完整的测试计划)；
	从而控制多个测试计划组合，在执行时会执行导入的测试计划。
	2、但是被导入的测试计划有特殊要求，它不能有线程组，只能包含简单控制器及控制器下的元件。
	3、简单点说就是相当于加了一个执行单元，一个封装了的业务操作单元，类似我们程序开发中的函数一样。
	4、比如一个查询订单的业务操作我们用取样器来模拟，然后放到简单控制器中作为一个执行单元，
	别的地方也要用到时，我们可以不重写直接引用过来，这就类似我们 Java 开发中的方法封装。
	 
	// ************************* 【Include 控制器】 参数说明 ************************* //
	1、名称：Include 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、文件名：必输字段，如果没有则会报错。
	包含测试计划的文件名，可以点击浏览，从文件夹保存的 JMX 文件夹目录下选择对应的 JMX 文件。
	 
	 
	// ************************* 【Include 控制器】 使用方法 ************************* //
	1、创建一个测试计划，下面可添加取样器/控制器等，然后保存测试计划，为了方便起见, 
	线程组也可以添加外部JMX文件中用于调试；
	 
	2、如果测试使用Cookie或用户定义的变量,这些应放置在顶层（包括文件）,否则无法正常工作；
	此元素不支持变量/函数在文件名字段中；但是,如果属于包含控制器定义的内容，则使用前缀路径名。
	 
	3、当使用包含控制器中包含相同的JMX文件,则要确保文件名不同,以避免无法读取；
	如果文件不能被发现，那么控制器会尝试打开文件名相对于JMX启动目录。

8、Interleave Controller【交替控制器】
	交替控制器：交替控制器，其节点下的取样器会交替执行，使得该控制器包含的取样器步骤交错执行在每个循环中
	 
	// ************************* 【交替控制器】 参数说明 ************************* //
	1、名称：交替控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、忽略资控制器块：jmeter 汉化错别字，应为——忽略子控制器模块
	忽略子控制器，即子控制器失效，由交替控制器接管。
	[勾选：如果勾选此项,交替控制器将子控制器像单一请求元素一样，一次只允许一个请求/控制器；
	默认不勾选：否]
	 
	4、Interleave across threads：是否跨线程交错
	[勾选：是；默认不勾选：否]
	 
	// ************************* 【交替控制器】 使用方法 ************************* //
	假使该控制器下有2个取样器 A 和 B ，交替执行 A 和 B 2个请求，即每次传递一个子请求到这个测试，按子元件的排列顺序。

9、Once Only Controller【仅一次控制器】
	仅一次控制器：
	1、在多线程循环的时候，将使其子节点下的取样器请求只运行一次。
	2、也就是此控制器下的子元件只运行一次，即使把仅一次控制器放在循环控制器下面，也只是运行一次。
	3、我们在模拟请求时有时只需要登录一次，就可以把登录的部分放在仅一次控制器下。
	 
	// ************************* 【仅一次控制器】 参数说明 ************************* //
	1、名称：仅一次控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

10、Random Controller【随机控制器】
	随机控制器：
	1、类似交替控制器，但该控制器随机选取某一个取样器请求并执行。
	2、随机控制器节点下的元件随机运行，与交替控制器不一样的是节点下的元件运行顺序不定。
	 
	// ************************* 【随机控制器】 参数说明 ************************* //
	1、名称：随机控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、忽略资控制器块：jmeter 汉化错别字，应为——忽略子控制器模块
	忽略子控制器，即子控制器失效，由随机控制器接管。
	[勾选：如果勾选此项,随机控制器将子控制器像单一请求元素一样，一次只允许一个请求/控制器；
	默认不勾选：否]

11、Random Order Controller【随机顺序控制器】
	随机顺序控制器：
	1、类似于简单控制器，将执行每个子节点下的取样器请求一次，但是执行是随机的。
	2、其节点下的元件随机执行，不过每个元件只执行一次。
	 
	// ************************* 【随机顺序控制器】 参数说明 ************************* //
	1、名称：随机顺序控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

12、Recording Controller【录制控制器】
	录制控制器：
	1、顾名思义是录制的时候用到的，类似代理服务器的作用，在测试执行期间记录测试样本。
	2、实际上它是一个位置，当我们用 JMeter 代理进行录制时，录制的脚本默认放在此控制器的节点下面。
	3、没有实际的逻辑作用，我们用简单控制器也可以代替它。
	 
	// ************************* 【录制控制器】 参数说明 ************************* //
	1、名称：录制控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Clear all the recorded samples：清除所有记录的样本
	[点击可以清除所有已经记录的测试样本]

13、Runtime Controller【Runtime 控制器】
	Runtime 控制器：生命周期/运行周期控制器，用来控制其子元件的执行时长，时长的单位是秒。
	 
	// ************************* 【Runtime 控制器】 参数说明 ************************* //
	1、名称：Runtime 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Runtime (seconds): 执行时长（运行时间）
	[默认为 1 ；去掉 1 则默认为 0 ，此时不执行其节点下的元件；其他自定义修改数字。]

14、Simple Controller【简单控制器】
	简单控制器：
	1、用来指定了一个执行单元，它不改变元件的执行顺序。
	2、在简单控制器下面还可以嵌套其他控制器。
	3、简单控制器是最基本的控制器，对jmeter测试运行没有任何影响，可用来命名某些操作。
	 
	// ************************* 【简单控制器】 参数说明 ************************* //
	1、名称：简单控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 

15、jp@gc - Parameterized Controller
	jp@gc - Parameterized Controller：
	1、jp@gc - 参数化控制器，可以通过JMeter插件来监控服务器CPU、内存、磁盘、网络等相关资源。
	2、安装服务器监控插件后，此控制器才会出现：
	其中 JMeterPlugins-Standard 和 JMeterPlugins-Extras 是客户端的，ServerAgent 是服务端的。
	 
	// ****************** 【jp@gc - Parameterized Controller】 参数说明 ****************** //
	1、名称：jp@gc - Parameterized Controller名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。 
	 
	3、Help on this plugin ：关于此插件的帮助
	[点击查看官方说明文档]
	 
	4、用户定义的变量
	（1）名称：用户定义的所有变量的总名称，可以随意设置，甚至可以为空。 
	（2）注释：可以随意设置，可以为空。 
	（3）列表：
	● 名称：用户定义的变量名
	● 值：用户定义的变量值
	● Description：描述
	[按钮：详细、添加、从剪切板添加、删除、向下、向上]

16、Throughput Controller【吞吐量控制器】
	吞吐量控制器：
	1、应该译为：流量控制器，jmeter自带的翻译这里是错误的，因为它并不能控制吞吐量。
	2、吞吐量控制器，用来控制其下元件的执行次数，并无控制吞吐量的功能，
	其实质作用是允许用户控制执行的频率。
	3、想要控制吞吐量可以使用定时器： Constant Throughput Timer 。
	4、吞吐量控制器有两种模式: Total Executions 与 Percent Executions 。
	 
	// ************************* 【吞吐量控制器】 参数说明 ************************* //
	1、名称：吞吐量控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、下拉框：吞吐量控制器模式二选一
	（1）Percent Executions [默认]：执行百分比
	● 使控制器按一定比例执行迭代的测试计划
	● 按执行次数的百分比来计算执行次数，此时“吞吐量”取值是 0~100 。
	（2）Total Executions：总执行次数
	● 使控制器停止执行一定数量的测试计划
	● 按 Throughput 的值来指定执行次数，此时“吞吐量”可以是任意整数，如果小于等于零则一次也不执行。
	 
	4、吞吐量：流量
	（1）Percent Executions 模式下：执行百分比，取值是 0~100
	（2）Total Executions 模式下：总执行次数，任意整数
	 
	5、Per User：是否所有虚拟用户
	（1）Percent Executions 模式下：Per User 是否勾选对此模式无影响。
	（2）Total Executions 模式下：此时 Per User 与 Total Executions一起来影响执行次数。
	[勾选：是，按虚拟用户数来计算执行次数；默认不勾选：否，按所有虚拟用户来计算执行次数]

17、Module Controller【模块控制器】
	模块控制器：可以通过模块控制器在当前测试计划中引入新的测试片段（也可以叫脚本片段，由控制器、
	取样器及辅助元件构成，能够完成负载的模拟）。
	 
	// ************************* 【模块控制器】 参数说明 ************************* //
	1、名称：模块控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、Find target element：查找目标元素
	寻找测试计划中需要特定测试的元素、模块，也可理解为该控制器可以控制已经封装好的模块元素
	[点击此按钮，再点击 “Module To Run” 下的原件，模块控制器会直接切换跳转到该元件。
	不点击此按钮，点击 “Module To Run” 下的原件，依旧停留在模块控制器。]
	 
	4、Module To Run: 模块运行下拉列表
	列出了测试计划及工作台包含的控制器，在此选择需要引入其中的一个脚本片段。
	 
	 
	// *************************** 【模块控制器】 作用 *************************** //
	● 一个测试计划由一个控制器和所有的测试元素（取样器等）组成，测试计划可以位于任何线程组或工作台；
	如果计划位于线程组，则可以禁用其他控制器，防止正在运行的测试计划被影响（除了模块控制器）
	 
	● 模块控制器的优势在于：当存在多个线程组时，该控制器可以轻松切换，只需要选择对应的取样器，
	方便快捷，替代了创建很多测试计划的繁琐操作
	 
	● 任何一个模块所用的控制器名字必须唯一，因为其名字被用来找到目标控制器时重新加载；
	出于这个原因，最好保证控制器名字不同，否则执行测试时候可能发生意外
	 
	● 模块控制器与远程测试不应使用或非gui测试与工作台部件，因为工作台测试元素并没有测试计划的
	一部分 jmx 文件，任何这样的测试就会失败。

18、Switch Controller【Switch 控制器】
	Switch 控制器：
	1、Switch 条件控制器，转换控制器，类似于高级语言中的 Switch 逻辑控制语句，
	通过给该控制器中的 value 赋值，来指定运行哪个取样器（也可以理解为开关控制器）。
	2、例如指定运行的取样器编号为 0 (JMeter 会给节点下的取样器顺序编号，第一个取样器 "Java 请求"编号为 0 ，
	第二个取样器"Java 请求 2" 的编号就是 1 ，所以这里指定 0 就会运行第一个 Java 请求)。
	3、如果指定的编号超出了下面的节点数或者不指定，则运行第 0 个取样器。
	4、也可以指定取样器的名称，名称匹配时大小写及空格都敏感，如果匹配不上则不运行取样器。
	 
	// ************************* 【Switch 控制器】 参数说明 ************************* //
	1、名称：Switch 控制器名称，可以随意设置，甚至可以为空。 
	 
	2、注释：可以随意设置，可以为空。
	 
	3、Switch Value：控制器具体赋值的 value 值字段
	（1）第一种是数值：Switch控制器下的子节点从0开始计数，通过指定子节点所在的数值来确定执行哪个元素。
	（2）第二种是字符：直接指定子元素的名称，比如取样器名称来进行匹配。
	● 当指定的名称不存在时，不执行任何元素。
	● 当 Value 为空时，默认执行第 1 个子节点元素。






























