
"""
变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；
而一个对象，可以被多个变量所指向。可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。
但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。变量可以被删除，但是对象无法被删除。
"""


"""
Python 的参数传递是赋值传递 （pass by assignment），
或者叫作对象的引用传递（pass by object reference）。
"""



#01
"""
这里的参数传递，使变量 a 和 b 同时指向了 1 这个对象。
但当我们执行到 b = 2 时，系统会重新创建一个值为 2 的新对象，并让 b 指向它；
而 a 仍然指向 1 这个对象。所以，a 的值不变，仍然为 1。
"""

def my_func1(b):
	b=2
a = 1
my_func1(a)
print(a)




#02
"""
让函数返回新变量，赋给 a。
这样，d 就指向了一个新的值为 3 的对象，d 的值也因此变为 3。
"""
def my_func2(c):
	c=3
	return c
d = 2
d=my_func2(d)
print(d)


def my_func2(b):
  b = 2
  return b

a = 1
a = my_func2(a)
print(a)



#03
"""
当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量。
这里 l1 和 l2 先是同时指向值为[1, 2, 3]的列表。
不过，由于列表可变，执行 append() 函数，对其末尾加入新元素 4 时，变量 l1 和 l2 的值也都随之改变了。
"""
def my_func3(l2):
  l2.append(4)

l1 = [1, 2, 3]
my_func3(l1)
l1
[1, 2, 3, 4]




#04
"""
这里 l2 = l2 + [4]，表示创建了一个“末尾加入元素 4“的新列表，
并让 l2 指向这个新的对象。这个过程与 l1 无关，因此 l1 的值不变。
"""

def my_func4(l2):
  l2 = l2 + [4]

l1 = [1, 2, 3]
my_func4(l1)
l1
[1, 2, 3]


#05
"""
同样的，如果要改变 l1 的值，我们就得让上述函数返回一个新列表，再赋予 l1 即可。

这里你尤其要记住的是，改变变量和重新赋值的区别：
my_func3() 中单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变；
但 my_func4() 中则创建了新的对象，并赋值给一个本地变量，因此原变量仍然不变。
"""

"""
至于 my_func3() 和 my_func5() 的用法，两者虽然写法不同，但实现的功能一致。
不过，在实际工作应用中，我们往往倾向于类似 my_func5() 的写法，添加返回语句。这样更简洁明了，不易出错。
"""
def my_func5(l2):
  l2 = l2 + [4]
  return l2

l1 = [1, 2, 3]
l1 = my_func5(l1)
l1
[1, 2, 3, 4]



"""
总结
今天，我们一起学习了 Python 的变量及其赋值的基本原理，并且解释了 Python 中参数是如何传递的。
和其他语言不同的是，Python 中参数的传递既不是值传递，也不是引用传递，而是赋值传递，或者是叫对象的引用传递。

需要注意的是，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。
如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。
如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。
清楚了这一点，如果你想通过一个函数来改变某个变量的值，通常有两种方法。
一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；
第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。
在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。

"""



























